// Tiny README generator (<150 lines, no external deps)
// - Reads partials from packages/docs/*.md
// - Emits README with title, AUTO-GENERATED notice, file tree, scripts table, env table
// Run via: pnpm -s docs:build

import { readdirSync, readFileSync, statSync, writeFileSync } from 'node:fs';
import { join, relative } from 'node:path';

const ROOT = process.cwd();

// Read docs partials in lexicographic order
function readPartials(): string {
  const dir = join(ROOT, 'packages', 'docs');
  let parts: string[] = [];
  try {
    const files = readdirSync(dir).filter((f) => f.endsWith('.md')).sort();
    parts = files.map((f) => readFileSync(join(dir, f), 'utf8').trim());
  } catch {
    // Optional: if no docs folder yet, leave empty
  }
  return parts.filter(Boolean).join('\n\n');
}

// Build a simple file tree, excluding heavy dirs
const EXCLUDES = new Set(['node_modules', '.git', '.next', 'dist']);
function tree(dir: string, prefix = ''): string[] {
  const entries = readdirSync(dir).filter((e) => !EXCLUDES.has(e)).sort();
  const lines: string[] = [];
  entries.forEach((name, idx) => {
    const full = join(dir, name);
    const isDir = statSync(full).isDirectory();
    const connector = idx === entries.length - 1 ? '└── ' : '├── ';
    lines.push(prefix + connector + name);
    if (isDir) {
      const nextPrefix = prefix + (idx === entries.length - 1 ? '    ' : '│   ');
      lines.push(...tree(full, nextPrefix));
    }
  });
  return lines;
}

// Collect scripts from root and app packages
function scriptsTable(): string {
  type Row = { scope: string; script: string; cmd: string };
  const rows: Row[] = [];
  const pkgs = [
    { scope: 'root', path: join(ROOT, 'package.json') },
    { scope: 'web', path: join(ROOT, 'apps', 'web', 'package.json') },
    { scope: 'worker', path: join(ROOT, 'apps', 'worker', 'package.json') },
  ];
  for (const p of pkgs) {
    try {
      const json = JSON.parse(readFileSync(p.path, 'utf8'));
      const scripts = json.scripts || {};
      Object.keys(scripts).forEach((k) => rows.push({ scope: p.scope, script: k, cmd: scripts[k] }));
    } catch {}
  }
  const header = '| Scope | Script | Command |\n|---|---|---|';
  const body = rows
    .sort((a, b) => (a.scope + a.script).localeCompare(b.scope + b.script))
    .map((r) => `| ${r.scope} | ${r.script} | \`${r.cmd}\` |`)
    .join('\n');
  return [header, body].join('\n');
}

// Extract environment variables from .env.example (supports commented pairs)
function envTable(): string {
  let lines: string[] = [];
  try {
    lines = readFileSync(join(ROOT, '.env.example'), 'utf8').split('\n');
  } catch {
    return '_No .env.example found_';
  }
  const rows: { k: string; v: string }[] = [];
  for (let raw of lines) {
    let s = raw.trim();
    if (!s) continue;
    if (s.startsWith('#')) s = s.replace(/^#+\s*/, '');
    if (!s.includes('=')) continue;
    const idx = s.indexOf('=');
    const k = s.slice(0, idx).trim();
    const v = s.slice(idx + 1).trim();
    if (k) rows.push({ k, v });
  }
  if (!rows.length) return '_No environment variables defined in .env.example_';
  const header = '| Name | Example / Default |\n|---|---|';
  const body = rows.map((r) => `| ${r.k} | ${r.v} |`).join('\n');
  return [header, body].join('\n');
}

// Assemble README content
const title = '# Canva-lite Monorepo';
const notice = '> AUTO-GENERATED – Do not edit directly. Run `pnpm docs:build`.';
const partials = readPartials();
const treeBlock = ['```', ...tree(ROOT), '```'].join('\n');

const content = [
  title,
  '',
  notice,
  '',
  partials,
  '',
  '## File Tree',
  treeBlock,
  '',
  '## Scripts',
  scriptsTable(),
  '',
  '## Environment',
  envTable(),
  '',
  '_Generated by `packages/scripts/build-readme.ts`_',
].join('\n');

writeFileSync(join(ROOT, 'README.md'), content, 'utf8');
console.log('README.md generated');
